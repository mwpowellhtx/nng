ZeroTier Mapping for Scalability Protocols
===========================================

sp-zerotier-mapping-04
~~~~~~~~~~~~~~~~~~~~~~

Abstract
--------

This document defines the ZeroTier mapping for scalability protocols.

Status of This Memo
-------------------

This is the third draft document, and is intended to guide early
development efforts.  Nothing here is finalized yet.

Copyright Notice
----------------

Copyright 2017 Garrett D'Amore <garrett@damore.org> +
Copyright 2017 Capitar IT Group BV <info@capitar.com>

At this point, all rights are reserved. (Note that we do intend to
release this under a liberal reuse license once it stabilizes a bit.)

Underlying protocol
-------------------

ZeroTier expresses an 802.3 style layer 2, where frames maybe excchanged as if
they were Ethernet frames.  Virtual broadcast domains are created within a
numbered "network", and frames may then be exchanged with any peers on that
network.

Frames may arrive in any order, or be lost, just a with Ethernet
(best effort delivery), but they are strongly protected by a
cryptographic checksum, so frames that do arrive will be uncorrupted.
Furthermore, ZeroTier guarantees that a given frame will be received
at most once.

Each application on a ZeroTier network has its own address, called a
ZeroTier ID (`ZTID`), which is globally unique -- this is generated
from a hash of the public key associated with the application.

A given application may participate in multiple ZeroTier networks.

We assume each SP application will have it's own ZeroTier ID,
and will not use more than one.  Management of these IDs, as well as
the underlying key pairs, is out of scope of this document.

ZeroTier networks have a standard MTU of 2800 bytes.
They may be configured to have larger MTUs, but typically this involves
extensive reassembly at underlying layers, and so larger MTUs are not
used in this specification.

They also have an "optimum" MTU, based upon the underlying networks
(typically UDP) and overheads that are used to exchange such packets.
For our purposes we will assume this to be approximately 1400 bytes.
These values can change on different networks.

Packet layout
~~~~~~~~~~~~~

Each SP message sent over ZeroTier will be comprised of one or
more fragments, where each fragment is mapped to a single underlying
ZeroTier L2 frame.  We use the EtherType field of 0901 to indicate
SP over ZeroTier protocol (number to registered with IEEE).

Each frame shall be prepended with the following header:

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |              destination mac address (bytes 0-3)              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  destination mac (bytes 4-5)  |    source mac (bytes 0-1)     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                   source mac address (bytes 2-5)              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    0x90       |   0x01        |  op   | flags |   version     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  reserved     |                destination port               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  reserved     |                  source port                  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     payload...
   +-+-+-+-+-+-+-+-

All numeric fields are in big-endian byte order.

As above, the start of each frame is just as a normal Ethernet frame,
with destination, source, and type of 0x901.  (It is possible for a
tag to be present between the ethertype and the source address.  If
present, that shall follow the standards for Ethernet tagged frames.
The use of Ethernet tags, typically for QoS or VLANs, is not discussed
further here.)

The `op` is a field that indicates the type of message being sent.  The
following values are defined: `DATA` (0), `CONN` (1), `DISC` (2), `PING` (3),
and `ERR` (4).  These are discussed further below.  Implementations
*MUST* discard messages where the `op` is not one of these.

There are two `flags` defined.  The first is `MF` (1), which indicates
that a message is fragmented, and more fragments follow.  This flag
may only be set on `DATA` messages.  The last fragment of a message
will not have this flag set.

The second flag is `AK` (2), which indicates that a given message is a
reply to an earlier message.  This is only valid for the `CONN`, `DISC`,
and `PING` message types.

Note that the `MF` and the `AK` flag bits are mutually exclusive.

The `version` byte MUST be set to 0x1.  Implementations *MUST* discard
any messages received for any other version.

The `source port` and `destination port` are used to construct a logical
conversation.  These are 24-bits wide, and are discussed further below.
The `reserved` fields must be set to zero.

The remainder of frame varies depending on the `op` used.

The fragment length and offset are given in terms of octets, and only
include the payload.  For example, the first fragment of a message
bearing a 2000 byte payload, itself only carrying 1400 bytes of that
payload would have the `MF` bit set in flags, offset 0, and length
1400.  The second fragment would have the `MF` bit clear, length 600,
and offset 1400.

As a single fragment cannot exceed the size of a ZeroTier frame, the
high order six bits of the fragment length *MUST* be zero, and the
value encoded MUST be less than 2800.

Each fragment for a given message must carry the same `message ID`.
Implementations MUST initialize this to a random value, and *MUST*
increment this each time a new message is sent.

The port fields are used to discriminate different uses, allowing one
application to have multiple connections or sockets open.  The
purpose is analogous to TCP port numbers, except that instead of the
operating system performing the discrimination the application or
library code must do so.  Note that port numbers are 24-bits.  This
was chosen to allow a peer to allocate a unique port number for each
local conversation, allowing up to 16 million concurrent conversations.
This also allows a 40-bit node number to be combined with the 24-bit
port number to create a 64-bit unique address.

The `type` field is the numeric SP protocol ID, in big-endian form.
When receiving a message for a port, if the SP protocol ID does not
match the SP protocol expected on that port, the implementation *MUST*
discard this message.

Note that it is not by accident that the payload is 32-bit aligned in
this message format.  The payload is actually 64-bit aligned.

Source and destination MAC addresses shall be constructed
algorithmically from the relevant ZeroTier IDs.

Note that at this time, broadcast and multicast is not supported by
this mapping.  (A future update may resolve this.)

DATA messages
~~~~~~~~~~~~~

`DATA` messages carry SP protocol payload data.  They can only be sent
on an established session (see `CONN` messages below), and are never
acknowledged (in this version).

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         message ID            |        fragment length        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       fragment offset                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       user data...
   +-+-+-+-+-+-+-+-

This allows for a maximum message size of 4GB, made of fragments of
at most 64K.  However, due to current considerations with respect to
the size of ZeroTier frames (which are limited to several KB), and
the fact that as the fragment count increases the likelihood of
losing a fragment and having to resend a large message increases
severely, the current protocol should not be used to transmit messages
larger than a MB or so.  Future updates to add data acknowledgement are
anticipated to resolve this.

The `fragment length` is the number of bytes of `user data` following
the data header.  A given fragment is restricted to at most 64K, but
realistically will be more restricted by the underlying ZeroTier MTU.


CONN messages
~~~~~~~~~~~~~

`CONN` frames represent a session establishment.  They allow a peer to
advertise its port number to a remote peer, and to verify that a peer
is responsive.  The payload for the `CONN` frame is a 2 byte (big-endian)
value, consisting of the SP protocol ID of the sender:

    0                   1
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         SP protocol ID          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

The connection is initiated by the initiator sending this message,
with its own SP protocol ID.  The `AK` flag will in this case be clear.
The initiator must choose a `source port` number that is not currently
being used with the remote peer. (Most implementations will choose a
a source port that is not used at all. It is recommended that source
port numbers be chosen randomly.)

The responder will acknowledge this by replying with its SP protocol
ID in the 4-byte payload, with the `AK` flag set.   Additionally,
the source port number that the responder replies with MAY be different
than the one the intiator requested.  The reason for this is to allow
a responder to use these port numbers to uniquely identify a new
conversation.

Alternatively, a responder may reject the connection attempt by
sending a suitably formed ERR message (see below).

If a sender does not receive a reply, it SHOULD retry this message
before giving up and reporting an error to the user.  It is recommended
that a configurable number of retries and time interval be used.
Given modern Internet latencies of generally less than 500 ms, resending
up to 5 CONN requests, once every second, before giving up seems
reasonable.

If a `CONN` frame is received for a session that already exists, the
receiver MUST reply.  Further, the source port it replies with, and
the SP protocol IDs MUST be identical to what it first sent.  This
ensures that the `CONN` request is idempotent.

DISC messages
~~~~~~~~~~~~~

DISC messages are used to request a session be terminated.  This
notifies the remote sender that no more data will be sent or
accepted, and the session resources may be released.  There is no
payload.  The party closing the session sends this with the AK flag
clear.  There is no acknowledgement.

PING messages
~~~~~~~~~~~~~

In order to keep session state, implementations will generally store
data for each session.  In order to prevent a stale session from
consuming these resources forever, and in order to keep underlying
ZeroTier sessions alive, a `PING` message may be sent.  This message
has no payload.

The sender *MUST* leave the `AK` bit clear.  If the `PING` is is
successful, then the responder *MUST* reply with a `PING` message with
the AK bit set.

In the event of an error, an implementation _MAY_ reply with an `ERR`
message.

Implementations *MUST* not initiate `PING` messages if they have either
received or sent other session messages recently.

Implementations shall use a timeout T1 seconds of be used before
initiating a message the first time, and that in the absence of a
reply, up to N further attempts be made, separated by T2 seconds.  If
no reply to the Nth attempt is received after T2 seconds have passed,
then the remote peer should be assumed offline or dead, and the
session closed.

It is recommended that T1, T2, and N all be configurable, with
recommended default values of 60, 10, and 5.  With these values,
sessions that appear dead after 2 minutes will be closed, and their
resources reclaimed.

ERR messages
~~~~~~~~~~~~

`ERR` messages indicate a failure in the session, and abruptly
terminate the session.  The payload for these messages consists of a
single byte error code, followed by an ASCII message describing the
error (not terminated by zero).  This message *MUST NOT* be more than
128 bytes in length.

The following error codes are defined:

     * 0x01 No party listening at that address or port.
     * 0x02 No such session found.
     * 0x03 SP protocol ID invalid.
     * 0x04 Generic protocol error.
     * 0x05 Message size too big.
     * 0xff Other uncategorized error.

Implemenations *MUST* discard any session state upon receiving an ERR
message.  These messages are not acknowledged.

Reassembly Guidelines
~~~~~~~~~~~~~~~~~~~~~

Implementations *MUST* accept and reassemble fragmented `DATA` messages.
Implementations *MUST* discard fragmented messages of other types.

Messages larger than the ZeroTier MTU (2800) *MUST* be fragmented.

Implementations *SHOULD* limit the number of unassembled messages
retained for reassembly, to minimize the likelihood of intentional
abuse.  It is suggested that at most 2 unassembled messages be
retained.  It is further suggested that if 2 or more unfragmented
messages arrive before a message is reassembled, or more than 5
seconds pass before the reassembly is complete, that the unassembled
fragments be discarded.


Ports
~~~~~

The port numbers are 24-bit fields, allowing a single ZT ID to
service multiple application layer protocols, which could be treated
as seperate end points, or as separate sockets in the application.
The implementation is responsible for discriminating on these and
delivering to the appropriate consumer.

As with UDP or TCP, it is intended that each party have its own port
number, and that a pair of ports (combined with ZeroTier IDs) be used
to identify a single conversation.

An SP server should allocate a port for number advertisement.  It is
expected clients will generate ephemeral port numbers.

Implementations are free to choose how to allocate port numbers, but
it is recommended manually configured port numbers are small, with
the high order bit clear, and that numbers > 2^23 (high order bit
set) be used for ephemeral allocations.

It is recommended that separate short queues (perhaps just one or two
messages long) be kept per local port in implementations, to prevent
head-of-line blocking issues where backpressure on one consumer
(perhaps just a single thread or socket) blocks others.

URI Format
~~~~~~~~~~

The URI scheme used to represent ZeroTier addresses makes use of
ZeroTier IDs, ZeroTier network IDs, and our own 24-bit ports.

The format shall be `zt://<nwid>/<ztid>:<port>`, where the `<nwid>`
component represents the 64-bit hexadecimal ZeroTier network ID,
the `<ztid>` represents the 40-bit hexadecimal ZeroTier Device ID,
and the `<port>` is the 24-bit port number previously described.

// XXX: the ztid could use DNS names, generating 6PLANE IP addresses,
// and extracting the 10 digit device id from that.  Note that there
// is no good way to determine a nwid automatically.  The 6PLANE
// address is determined by a non-reversible XOR transform of the
// network id.

Security Considerations
~~~~~~~~~~~~~~~~~~~~~~~

The mapping isn't intended to provide any additional security in
addition to what ZeroTier does.
